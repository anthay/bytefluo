
                              bytefluo


0  PURPOSE

bytefluo is a C++ class for reading byte streams. You can use it to
read simple integer scalar values with a specified byte order from a
buffer, regardless of the native byte order of the computer on which
the code is running. It will throw an exception if any attempt is
made to access data beyond the specified bounds of the buffer.

The class was created to simplify the low-level parsing of binary
data structures and to avoid having to write code such as

 unsigned short foo = static_cast<unsigned short>(*bar++) << 8;
 foo |= static_cast<unsigned short>(*bar++);

or

 unsigned short foo = ntohs(*(unsigned short *)bar);
 bar += 2;

and instead just write

 unsigned short foo;
 bar >> foo;

(where this bar is a bytefluo object rather than the raw pointer of
the previous examples).


1  BUILDING

bytefluo is a C++ header-only library file; there are no other source
files to compile and no libs to link with. Just include bytefluo.h in
your code and start using it.


2  TESTING

The bytefluo library is distributed with a self-contained unit test in
the file bytefluo_test.cpp. Compile this file and run it.

OSX
 $ g++ -Wall bytefluo_test.cpp
 $ ./a.out
 tests executed 113, tests failed 0

Windows
 C:\test> cl /EHsc /W4 /nologo bytefluo_test.cpp
 C:\test> bytefluo_test
 tests executed 113, tests failed 0

The bytefluo library has been tested by the author under the following
compilers

 - gcc v4.0.1 on OSX
 - Microsoft Visual C++ v7 (2003) on Windows


3  USING

The unit test source, bytefluo_test.cpp, contains many examples of use.
Here is another:

 #include "bytefluo.h"

 int main()
 {
     const unsigned char bytes[8] = {
         0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77
     };
     bytefluo buf(bytes, bytes + sizeof(bytes), bytefluo::big_endian);
     unsigned long x;
     buf >> x;  // x = 0x00112233
     buf.set_byte_arrangement(bytefluo::little_endian);
     buf >> x;  // x = 0x77665544
 }


3.1  OVERVIEW

The important things to know about bytefluo are

 - When you create a bytefluo object you tell it what data it will
   provide access to, and the initial byte order for any scalar
   reads that will be performed.
 - The bytefluo object does not hold a copy of the given data; it
   merely manages access to that data.
 - The bytefluo object maintains a cursor, which is set initially
   at the start of the managed data. All reads begin at the current
   cursor location and advance the cursor by the size of the data
   read.
 - If a requested read or seek would take the cursor outside the
   bounds of the managed data the read or seek does not take place,
   the state of the bytefluo object remains unchanged and the
   bytefluo object throws a bytefluo_exception object, which is
   derived from std::runtime_error.
 - The bytefluo implementation is entriely within the header file,
   bytefluo.h. To use the class just #include "bytefluo.h".


3.2  DETAIL

3.2.1  CONSTRUCTION

 bytefluo(const void * begin, const void * end, byte_arrangement ba)
 bytefluo(const std::vector<unsigned char> & vec, byte_arrangement ba)

The bytefluo object will manage access to the bytes in the half open
range [begin, end) or the given vector 'vec'. Multi-byte scalars will
be read assuming the given byte order 'ba'. 'ba' must be one of

 bytefluo::big_endian     most-significant byte has lowest address
 bytefluo::little_endian  least-significant byte has lowest address

Throws bytefluo_exception if begin > end.

NOTE that the bytefluo constructor that takes a vector is provided as a
convenient shorthand for bytefluo(&vec[0], &vec[0] + vec.size(), ...)
(for a non-empty vector). Therefore any operations on the vector that
might change the value of &vec[0] (e.g. adding elements to the vector
may cause the vector to reallocate its buffer) will silently invalidate
the associated bytefluo object so that attempts to read the vector
contents via that bytefluo object may cause a CRASH.

E.g.
 unsigned char foo[99];
 bytefluo buf(foo, foo + sizeof(foo), bytefluo::big_endian);
E.g.
 std::vector<unsigned char> vec(99);
 bytefluo buf(vec, bytefluo::big_endian);


3.2.2  SET BYTE ORDER

 void set_byte_arrangement(byte_arrangement ba)

Specify the byte arrangement to be used on subsequent scalar reads.
'ba' must be one of

 bytefluo::big_endian     most-significant byte has lowest address
 bytefluo::little_endian  least-significant byte has lowest address

E.g.
 bytefluo buf(...);
 buf.set_byte_arrangement(bytefluo::big_endian);


3.2.3  READ INTEGER SCALAR

 template <typename scalar_type>
 bytefluo & operator>>(scalar_type & out)

Read an integer scalar value from buffer at current cursor position.
The scalar is read assuming the byte order set at construction or
ath the last call to set_byte_arrangement(). The cursor is advanced
by the size of the scalar read.

E.g.
 bytefluo buf(...);
 unsigned short foo, bar;
 buf >> foo >> bar;  // read two successive shorts, foo followed by bar


3.2.4  READ ARBITRARY NUMBER OF BYTES

 void read(void * dest, size_t len)

Copy 'len' bytes from buffer at current cursor position to given
'dest' location. The cursor is advanced by the number of bytes
copied. The current byte order setting has no affect on this
operation.

E.g.
 bytefluo buf(...);
 unsigned char foo[23];
 buf.read(foo, sizeof(foo));


3.2.5  MOVE THE CURSOR

 long seek_begin(long pos)
 long seek_current(long pos)
 long seek_end(long pos)

These functions move the cursor 'pos' bytes from stream beginning,
the current cursor location and the stream end respectively. They
all return the distance from buffer start to new cursor location.
seek_begin() and seek_end() require pos to be positive; seek_current()
may have a positive (move cursor toward end) or negative (move cursor
toward begin) actual parameter.

E.g.
 bytefluo buf(...);
 long pos = buf.seek_end(3);  // cursor is 3 bytes from buffer end


3.2.6  TEST FOR END OF STREAM

 bool eos() const

Return true if and only if the cursor is at the end of the stream.

E.g.
 bytefluo buf(...);
 buf.seek_end(0);
 bool at_end = buf.eos();  // at_end = true


3.2.7  STREAM SIZE

 size_t size() const

Return the number of bytes in the stream.

E.g.
 std::vector<unsigned char> v(99);
 bytefluo buf(v, bytefluo::little_endian);
 size_t siz = buf.size(); // siz = 99


3.2.8  CURSOR POSITION

 size_t tellg() const

Return the distance from the buffer start to the current cursor
location.

E.g.
 bytefluo buf(...);
 buf.seek_begin(13);
 buf.seek_current(-3);
 size_t pos = buf.tellg();  // pos = 10


4  LICENSE

 Copyright (c) 2008,2009 Anthony C. Hay
 Distributed under the BSD license, see:
 http://creativecommons.org/licenses/BSD/


5  AUTHOR

 Anthony C. Hay
 March 2009
 anthony.hay.1@gmail.com
